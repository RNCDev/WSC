<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSC Roster Builder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        table { border-collapse: separate; border-spacing: 0; width: 100%; }
        th, td { padding: 6px 8px; text-align: left; border-bottom: 1px solid #e0e0e0; }
        th, #memberGrid tr:first-child th:last-child { background-color: #f2f2f2 !important; }
        button { margin: 10px 5px 10px 0; padding: 5px 10px; }
        input[type="text"] { width: 90%; padding: 4px; border: none; background-color: transparent; font-size: 14px; }
        .action-column { width: 80px; }
        #fileInput { display: none; }
        .instructions { background-color: #f0f0f0; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        th, .header-action {background-color: #f2f2f2; /* Same as other headers */}
    </style>
</head>
<body>
    <h1>WSC Roster Builder</h1>
    <div class="instructions">
        <h2>Instructions:</h2>
        <ol>
            <li>Upload a CSV file with player data using the "Upload CSV" button.</li>
            <li>Edit player information directly in the grid [Name, Skill, Defense/Offense, Attendance].</li>
            <li>Add or remove rows as needed.</li>
            <li>Click "Generate Roster" to create balanced teams.</li>
            <li>Use "Go to Roster" to view the generated teams.</li>
        </ol>
    </div>
    <input type="file" id="fileInput" accept=".csv">
    <button id="uploadButton">Upload CSV</button>
    <button id="addRow">Add Row</button>
    <button id="generateRoster">Generate Roster</button>
    <button id="goToRoster">Go to Roster</button>
    <button id="clearGrid">Clear</button> <!-- Added the Clear button -->
    <table id="memberGrid"></table>
    <script>
        let gridData = [], headers = [];
        
        function handleFileUpload(event) {
            Papa.parse(event.target.files[0], {
                header: true,
                complete: function(results) {
                    gridData = results.data;
                    headers = results.meta.fields;
                    saveGridData();
                    renderGrid();
                },
                error: error => console.error('Error parsing CSV:', error)
            });
        }

    function renderGrid() {
    const grid = document.getElementById('memberGrid');
    grid.innerHTML = '';
    const headerRow = grid.insertRow();

    headers.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        headerRow.appendChild(th);
    });

    const actionTh = document.createElement('th');
    actionTh.textContent = 'Action';
    actionTh.className = 'header-action';
    headerRow.appendChild(actionTh);

    gridData.forEach((row, index) => {
        const tr = grid.insertRow();

        headers.forEach(header => {
            const td = tr.insertCell();
            const input = document.createElement('input');
            input.type = 'text';
            input.value = row[header] || '';
            input.addEventListener('change', e => {
                gridData[index][header] = e.target.value;
                saveGridData();
            });
            td.appendChild(input);
        });

        const actionCell = tr.insertCell();
        actionCell.className = 'action-column';
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.onclick = () => deleteRow(index);
        actionCell.appendChild(deleteButton);
        });
        }
        
        function addRow() {
            gridData.push(Object.fromEntries(headers.map(header => [header, ''])));
            saveGridData();
            renderGrid();
        }
        
        function deleteRow(index) {
            gridData.splice(index, 1);
            saveGridData();
            renderGrid();
        }

        function saveGridData() {
            localStorage.setItem('gridData', JSON.stringify(gridData));
            localStorage.setItem('headers', JSON.stringify(headers));
        }

        function loadGridData() {
            const savedGridData = localStorage.getItem('gridData');
            const savedHeaders = localStorage.getItem('headers');
            if (savedGridData && savedHeaders) {
                gridData = JSON.parse(savedGridData);
                headers = JSON.parse(savedHeaders);
                renderGrid();
            }
        }

        function clearGrid() {
            gridData = [];
            headers = [];
            localStorage.removeItem('gridData');
            localStorage.removeItem('headers');
            renderGrid();
        }
        
        function goToRoster() {
            window.location.href = 'roster.html';
        }
        
        function generateRosters(gridData) {
            const attendingPlayers = gridData.filter(player => player.Attendance === "1");
            if (attendingPlayers.length === 0) {
                console.warn("No attending players found. Cannot generate rosters.");
                return [];
            }
        
            // Parse skills and add position property
            attendingPlayers.forEach(player => {
                player.Skill = parseFloat(player.Skill);
                player.position = player.Defense === "1" ? "Defense" : "Forward";
            });
        
            // Group players by position
            const defensePlayers = attendingPlayers.filter(player => player.position === "Defense");
            const forwardPlayers = attendingPlayers.filter(player => player.position === "Forward");
        
            const teams = { Red: [], White: [] };
            const teamScores = { Red: 0, White: 0 };
            const teamPositions = {
                Red: { Defense: 0, Forward: 0 },
                White: { Defense: 0, Forward: 0 },
            };
        
            // Assign players by position with balancing
            assignPlayersByPosition(defensePlayers);
            assignPlayersByPosition(forwardPlayers);
        
            // Balance positions if necessary
            balancePositions();
        
            // Balance teams by swapping players
            balanceTeams();
        
            console.log(`Final Red Team Total Skill Score: ${teamScores.Red}`);
            console.log(`Final White Team Total Skill Score: ${teamScores.White}`);
        
            return [...teams.Red, ...teams.White];
        
            // Helper function to assign players by position
            function assignPlayersByPosition(players) {
                // Group players by skill
                const skillGroups = groupBy(players, 'Skill');
        
                // Get unique skills sorted in descending order
                const uniqueSkills = Object.keys(skillGroups).map(parseFloat).sort((a, b) => b - a);
        
                uniqueSkills.forEach(skill => {
                    const playersInSkill = skillGroups[skill];
        
                    // Shuffle players within the skill
                    shuffleArray(playersInSkill);
        
                    playersInSkill.forEach(player => {
                        // Choose the team with the lower total skill score for this position
                        let teamName;
                        if (teamPositions.Red[player.position] < teamPositions.White[player.position]) {
                            teamName = 'Red';
                        } else if (teamPositions.Red[player.position] > teamPositions.White[player.position]) {
                            teamName = 'White';
                        } else {
                            // If counts are equal, randomly choose a team
                            teamName = Math.random() < 0.5 ? 'Red' : 'White';
                        }
        
                        teams[teamName].push({
                            First: player.First,    // Add First name
                            Last: player.Last,      // Add Last name
                            position: player.position,
                            team: teamName, 
                            skill: player.Skill
                        });
        
                        teamScores[teamName] += player.Skill;
                        teamPositions[teamName][player.position]++;
                    });
                });
            }
        
            // Helper function to group players by a key
            function groupBy(array, key) {
                return array.reduce((result, currentItem) => {
                    (result[currentItem[key]] = result[currentItem[key]] || []).push(currentItem);
                    return result;
                }, {});
            }
        
            // Helper function to shuffle an array in place
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
        
            // Helper function to balance positions between teams
            function balancePositions() {
                ['Defense', 'Forward'].forEach(position => {
                    let redCount = teamPositions.Red[position];
                    let whiteCount = teamPositions.White[position];
        
                    while (Math.abs(redCount - whiteCount) > 1) {
                        const sourceTeam = redCount > whiteCount ? 'Red' : 'White';
                        const targetTeam = sourceTeam === 'Red' ? 'White' : 'Red';
        
                        // Find a random player to move
                        const sourcePlayers = teams[sourceTeam].filter(p => p.position === position);
                        if (sourcePlayers.length === 0) break;
        
                        // Choose a random player to move
                        const playerToMove = sourcePlayers[Math.floor(Math.random() * sourcePlayers.length)];
        
                        // Move the player
                        teams[sourceTeam] = teams[sourceTeam].filter(p => p !== playerToMove);
                        teams[targetTeam].push(playerToMove);
                        playerToMove.team = targetTeam;
        
                        // Update scores and counts
                        teamScores[sourceTeam] -= playerToMove.skill;
                        teamScores[targetTeam] += playerToMove.skill;
        
                        teamPositions[sourceTeam][position]--;
                        teamPositions[targetTeam][position]++;
        
                        redCount = teamPositions.Red[position];
                        whiteCount = teamPositions.White[position];
                    }
                });
            }
        
            // Helper function to balance team skill scores by swapping players
            function balanceTeams() {
                let redScore = teamScores.Red;
                let whiteScore = teamScores.White;
        
                let improved = true;
                while (improved && Math.abs(redScore - whiteScore) > 0.5) {
                    improved = false;
        
                    const sourceTeam = redScore > whiteScore ? 'Red' : 'White';
                    const targetTeam = sourceTeam === 'Red' ? 'White' : 'Red';
        
                    // Attempt to find a swap that improves the balance
                    const sourcePlayers = teams[sourceTeam];
                    const targetPlayers = teams[targetTeam];
        
                    // Shuffle source and target players to introduce randomness
                    shuffleArray(sourcePlayers);
                    shuffleArray(targetPlayers);
        
                    outerLoop:
                    for (let i = 0; i < sourcePlayers.length; i++) {
                        for (let j = 0; j < targetPlayers.length; j++) {
                            const sourcePlayer = sourcePlayers[i];
                            const targetPlayer = targetPlayers[j];
        
                            // Swap players only if they play the same position
                            if (sourcePlayer.position !== targetPlayer.position) continue;
        
                            // Calculate new scores if swapped
                            const newRedScore = redScore - sourcePlayer.skill + targetPlayer.skill;
                            const newWhiteScore = whiteScore - targetPlayer.skill + sourcePlayer.skill;
                            const newDifference = Math.abs(newRedScore - newWhiteScore);
        
                            if (newDifference < Math.abs(redScore - whiteScore)) {
                                // Perform swap
                                teams[sourceTeam][teams[sourceTeam].indexOf(sourcePlayer)] = targetPlayer;
                                teams[targetTeam][teams[targetTeam].indexOf(targetPlayer)] = sourcePlayer;
        
                                sourcePlayer.team = targetTeam;
                                targetPlayer.team = sourceTeam;
        
                                teamScores[sourceTeam] = newRedScore;
                                teamScores[targetTeam] = newWhiteScore;
        
                                redScore = newRedScore;
                                whiteScore = newWhiteScore;
        
                                improved = true;
                                break outerLoop;
                            }
                        }
                    }
                }
            }
        }

        function generateRoster() {
            const rosters = generateRosters(gridData);
            if (rosters.length > 0) {
                localStorage.setItem('rosterData', JSON.stringify(rosters));
                window.location.href = 'roster.html';
            } else {
                alert("No rosters generated. Please check the player data.");
            }
        }

        document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        document.getElementById('uploadButton').onclick = () => document.getElementById('fileInput').click();
        document.getElementById('addRow').onclick = addRow;
        document.getElementById('generateRoster').onclick = generateRoster;
        document.getElementById('goToRoster').onclick = goToRoster;
        document.getElementById('clearGrid').onclick = clearGrid; // Link the Clear function

        window.onload = loadGridData;
    </script>
</body>
</html>
