<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Membership Grid</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        table { border-collapse: separate; border-spacing: 0; width: 100%; }
        th, td { 
            padding: 6px 8px; 
            text-align: left; 
            border-bottom: 1px solid #e0e0e0;
        }
        th { background-color: #f2f2f2 !important; } /* Force background on all headers */
        td:last-child { background-color: transparent; }
        button { margin: 10px 5px 10px 0; padding: 5px 10px; }
        input[type="text"] { 
            width: 90%; 
            padding: 4px; 
            border: none; 
            background-color: transparent; 
            font-size: 14px;
        }
        .action-column { width: 80px; }
        /* Specific rule for the last header */
        #memberGrid tr:first-child th:last-child {
            background-color: #f2f2f2 !important;
        }
    </style>
</head>
<body>
    <h1>WSC Roster Builder</h1>
    <button id="addRow">Add Row</button>
    <button id="generateRoster">Generate Roster</button>
    <button id="goToRoster">Go to Roster</button>
    <table id="memberGrid"></table>
    <script>
        let gridData = [];
        let headers = [];
        
        function loadCSV() {
            Papa.parse('Membership.csv', {
                download: true,
                header: true,
                complete: function(results) {
                    gridData = results.data;
                    headers = results.meta.fields;
                    console.log("CSV data loaded:", gridData);
                    renderGrid();
                },
                error: function(error) {
                    console.error('Error loading CSV:', error);
                }
            });
        }
        function renderGrid() {
            const grid = document.getElementById('memberGrid');
            grid.innerHTML = '';
            // Create header row
            const headerRow = grid.insertRow();
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            headerRow.insertCell().textContent = 'Action';
            // Create data rows
            gridData.forEach((row, index) => {
                const tr = grid.insertRow();
                headers.forEach(header => {
                    const td = tr.insertCell();
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = row[header] || '';
                    input.addEventListener('change', (e) => {
                        gridData[index][header] = e.target.value;
                    });
                    td.appendChild(input);
                });
                
                const actionCell = tr.insertCell();
                actionCell.className = 'action-column';
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => deleteRow(index);
                actionCell.appendChild(deleteButton);
            });
        }
        
        function addRow() {
            const newRow = {};
            headers.forEach(header => newRow[header] = '');
            gridData.push(newRow);
            renderGrid();
        }
        
        function deleteRow(index) {
            gridData.splice(index, 1);
            renderGrid();
        }
        
        function goToRoster() {
            // Navigate to roster.html
            window.location.href = 'roster.html';
        }

function generateRosters(gridData) {
    const attendingPlayers = gridData.filter(player => player.Attendance === "1");
    console.log("Attending players:", attendingPlayers);

    if (attendingPlayers.length === 0) {
        console.warn("No attending players found. Cannot generate rosters.");
        return [];
    }

    // Shuffle players
    const shuffledPlayers = shuffleArray(attendingPlayers);

    const defensemen = shuffledPlayers.filter(player => player.Defense === "1");
    const forwards = shuffledPlayers.filter(player => player.Defense === "0");

    const teams = { Red: { Defense: [], Forward: [] }, White: { Defense: [], Forward: [] } };

    // Distribute players evenly
    distributePlayersEvenly(defensemen, teams, "Defense");
    distributePlayersEvenly(forwards, teams, "Forward");

    // Balance teams based on total tier score
    balanceTeams(teams);

    return [...teams.Red.Defense, ...teams.Red.Forward, ...teams.White.Defense, ...teams.White.Forward];
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function distributePlayersEvenly(players, teams, position) {
    players.forEach((player, index) => {
        const team = index % 2 === 0 ? "Red" : "White";
        teams[team][position].push({
            name: player.Players,
            position: position,
            team: team,
            tier: parseInt(player.Tier)
        });
    });
}

function balanceTeams(teams) {
    const getTeamScore = (team) => 
        [...team.Defense, ...team.Forward].reduce((sum, player) => sum + player.tier, 0);

    let redScore = getTeamScore(teams.Red);
    let whiteScore = getTeamScore(teams.White);

    while (Math.abs(redScore - whiteScore) > 1) {
        const sourceTeam = redScore > whiteScore ? "Red" : "White";
        const targetTeam = sourceTeam === "Red" ? "White" : "Red";

        // Find the position with more players in the source team
        const sourcePositions = teams[sourceTeam].Defense.length > teams[sourceTeam].Forward.length ? ["Defense", "Forward"] : ["Forward", "Defense"];
        
        let playerToMove;
        for (const position of sourcePositions) {
            if (teams[sourceTeam][position].length > teams[targetTeam][position].length) {
                playerToMove = teams[sourceTeam][position].reduce((min, p) => p.tier < min.tier ? p : min);
                if (playerToMove) break;
            }
        }

        if (!playerToMove) break; // If we can't move any players, break the loop

        // Move the player
        const position = playerToMove.position;
        teams[sourceTeam][position] = teams[sourceTeam][position].filter(p => p !== playerToMove);
        playerToMove.team = targetTeam;
        teams[targetTeam][position].push(playerToMove);

        // Recalculate scores
        redScore = getTeamScore(teams.Red);
        whiteScore = getTeamScore(teams.White);
    }
}
        function generateRoster() {
            console.log("Grid data before roster generation:", gridData);
            const rosters = generateRosters(gridData);
            console.log("Generated rosters:", rosters);
            if (rosters.length === 0) {
                alert("No rosters were generated. Check if any players are marked as attending.");
            } else {
                localStorage.setItem('rosterData', JSON.stringify(rosters));
                console.log("Roster data saved to localStorage:", localStorage.getItem('rosterData'));
                window.location.href = 'roster.html';
            }
        }
        
        document.getElementById('addRow').addEventListener('click', addRow);
        document.getElementById('generateRoster').addEventListener('click', generateRoster);
        document.getElementById('goToRoster').addEventListener('click', goToRoster);
        loadCSV();
    </script>
</body>
</html>
